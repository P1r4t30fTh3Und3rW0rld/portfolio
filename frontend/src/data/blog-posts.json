[
  {
    "id": "building-secure-apis-nodejs-express",
    "title": "Building Secure APIs with Node.js and Express",
    "date": "2024-10-15",
    "excerpt": "Learn how to build secure, scalable APIs using Node.js and Express with best practices for authentication, validation, and error handling.",
    "content": "Building secure APIs is crucial in today's digital landscape. In this post, I'll share my experience and best practices for creating robust APIs using Node.js and Express.\n\n## Key Security Measures\n\n1. **Input Validation**: Always validate and sanitize user inputs\n2. **Authentication**: Implement proper JWT-based authentication\n3. **Rate Limiting**: Protect against brute force attacks\n4. **CORS Configuration**: Properly configure cross-origin requests\n\n## Code Example\n\n```javascript\nconst express = require('express');\nconst rateLimit = require('express-rate-limit');\nconst helmet = require('helmet');\n\nconst app = express();\n\n// Security middleware\napp.use(helmet());\napp.use(express.json({ limit: '10kb' }));\n\n// Rate limiting\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100 // limit each IP to 100 requests per windowMs\n});\napp.use('/api/', limiter);\n```\n\nThis approach ensures your APIs are both functional and secure.",
    "readTime": "5 min read",
    "author": "Priyanshu Chikara"
  },
  {
    "id": "exploring-nlp-spacy",
    "title": "Exploring Natural Language Processing with spaCy",
    "date": "2024-09-08",
    "excerpt": "Dive into the world of NLP using spaCy library. Learn how to process text, extract entities, and build language models.",
    "content": "Natural Language Processing (NLP) has become increasingly important in modern applications. spaCy is one of the most powerful and efficient NLP libraries available.\n\n## What is spaCy?\n\nspaCy is an open-source software library for advanced Natural Language Processing in Python. It's designed specifically for production use and helps you build applications that process and understand large volumes of text.\n\n## Key Features\n\n- **Named Entity Recognition (NER)**: Identify and classify named entities\n- **Part-of-Speech Tagging**: Determine grammatical parts of speech\n- **Dependency Parsing**: Analyze syntactic structure\n- **Text Classification**: Categorize text into predefined classes\n\n## Example Usage\n\n```python\nimport spacy\n\n# Load English language model\nnlp = spacy.load('en_core_web_sm')\n\n# Process text\ntext = 'Apple is looking at buying U.K. startup for $1 billion'\ndoc = nlp(text)\n\n# Extract entities\nfor ent in doc.ents:\n    print(ent.text, ent.label_)\n```\n\nThis will output:\n- Apple ORG\n- U.K. GPE\n- $1 billion MONEY\n\nspaCy makes NLP accessible and efficient for real-world applications.",
    "readTime": "7 min read",
    "author": "Priyanshu Chikara"
  },
  {
    "id": "mern-stack-best-practices",
    "title": "MERN Stack Best Practices for Scalable Apps",
    "date": "2024-08-20",
    "excerpt": "Discover best practices for building scalable applications using the MERN (MongoDB, Express, React, Node.js) stack.",
    "content": "The MERN stack is a popular choice for building full-stack JavaScript applications. Here are some best practices I've learned from building scalable applications.\n\n## Project Structure\n\nOrganize your code properly:\n```\nproject/\n├── client/          # React frontend\n├── server/          # Express backend\n├── shared/          # Shared utilities\n└── docs/           # Documentation\n```\n\n## Backend Best Practices\n\n1. **Environment Variables**: Use .env files for configuration\n2. **Error Handling**: Implement comprehensive error handling\n3. **Validation**: Use libraries like Joi for input validation\n4. **Database Design**: Plan your MongoDB schemas carefully\n\n## Frontend Best Practices\n\n1. **Component Structure**: Keep components small and focused\n2. **State Management**: Use Redux or Context API appropriately\n3. **Performance**: Implement code splitting and lazy loading\n4. **Testing**: Write unit and integration tests\n\n## Deployment Considerations\n\n- Use environment-specific configurations\n- Implement proper logging\n- Set up monitoring and analytics\n- Plan for database scaling\n\nFollowing these practices ensures your MERN applications are maintainable and scalable.",
    "readTime": "8 min read",
    "author": "Priyanshu Chikara"
  },
  {
    "id": "getting-started-blockchain-development",
    "title": "Getting Started with Blockchain Development",
    "date": "2024-07-12",
    "excerpt": "Learn the fundamentals of blockchain development and how to build your first smart contract using Ethereum and Solidity.",
    "content": "Blockchain technology has revolutionized how we think about decentralized applications. Let's explore how to get started with blockchain development.\n\n## Understanding Blockchain\n\nBlockchain is a distributed ledger technology that enables secure, transparent, and tamper-proof record-keeping. Key concepts include:\n\n- **Blocks**: Containers for transaction data\n- **Consensus**: Agreement mechanism among network participants\n- **Cryptography**: Ensures security and authenticity\n\n## Smart Contracts\n\nSmart contracts are self-executing contracts with the terms directly written into code. They run on the blockchain and automatically execute when conditions are met.\n\n## Solidity Basics\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract SimpleStorage {\n    uint256 private value;\n    \n    event ValueChanged(uint256 newValue);\n    \n    function setValue(uint256 newValue) public {\n        value = newValue;\n        emit ValueChanged(newValue);\n    }\n    \n    function getValue() public view returns (uint256) {\n        return value;\n    }\n}\n```\n\n## Development Tools\n\n- **Remix**: Online IDE for Solidity development\n- **Hardhat**: Development framework for Ethereum\n- **MetaMask**: Browser extension for wallet management\n- **Ganache**: Local blockchain for testing\n\nBlockchain development opens up exciting possibilities for decentralized applications.",
    "readTime": "10 min read",
    "author": "Priyanshu Chikara"
  },
  {
    "id": "implementing-string-pattern-matching-dfa",
    "title": "Implementing String Pattern Matching Using DFAs",
    "date": "2024-07-05",
    "excerpt": "Learn how to implement string pattern matching using Deterministic Finite Automata (DFAs) with practical examples in Go.",
    "content": "I took a course called Digital Systems Design in my previous semester and ended up really loving it. It was probably my favourite course that semester. In the course we learnt about basic logic gates, combinational and sequential circuits, finite state machines, programmable logic arrays, etc.\n\nI found all of this very interesting and dove deeper into these topics. In this post, we'll focus on one of these topics, Finite State Machines (FSMs) and use them to implement string pattern matching.\n\n## Understanding FSMs\n\nFinite State Machines are computational models used to design both programs and sequential circuits. They have a set of finite states, transitions between states, and actions, making them ideal for modelling behaviour that can be broken down into distinct steps.\n\n### Components of FSMs\n\n1. **States**: The different modes or conditions the system can be in.\n2. **Transitions**: Moving from one state to another, triggered by specific inputs or events.\n3. **Inputs**: Signals or events that cause the state to change.\n4. **Outputs**: Actions or signals that result from the current state or a state change.\n\n### Working of an FSM\n\nLet's consider a basic FSM designed to recognise binary strings that end with \"01.\"\n\n**States:**\n\n1. **S0:** The initial state.\n2. **S1:** State after reading '0'.\n3. **S2:** State after reading '01' (accepting state).\n\n**Transitions**\n\n| Current State | Input | Next State | Description                   |\n| ------------- | ----- | ---------- | ----------------------------- |\n| S0            | 0     | S1         | Transition to S1 on input '0' |\n| S0            | 1     | S0         | Remain in S0 on input '1'     |\n| S1            | 0     | S1         | Remain in S1 on input '0'     |\n| S1            | 1     | S2         | Transition to S2 on input '1' |\n| S2            | 0     | S1         | Transition to S1 on input '0' |\n| S2            | 1     | S0         | Transition to S0 on input '1' |\n\nIn this FSM, starting from the initial state **S0**, the machine reads each bit of the input string. If it ends in \"01\", the FSM will be in state **S2**, indicating a successful recognition of the pattern.\n\n### Types of FSMs\n\nThere are two main types of FSMs: Deterministic Finite Automata (DFA) and Non-Deterministic Finite Automata (NFA).\n\n**DFA**: In a DFA, each state has exactly one transition for each possible input. This makes them more predictable and easier to design. The above example that we just saw is an example of a DFA.\n\n**NFA**: An NFA, on the other hand, can have multiple transitions for the same input, including transitions to multiple states or none at all. This makes NFAs more flexible but also harder to implement and reason about.\n\n## Implementation\n\nNow that we know the basics of FSMs, and understand how DFAs work, we can implement string pattern matching by using DFAs.\n\nThe program will take two strings as input: a pattern string and an input string. If the pattern string is present in the input string, it will return true. Otherwise, it will return false. For example, if the pattern string is \"abc\" and the input string is \"ahabchf\", the program should return true, since the pattern \"abc\" is present in the input string. On the other hand, if the pattern string is \"def\" and the input string is \"ahabchf\", the program should return false, as the pattern \"def\" is not found in the input string.\n\nWe'll be using Go in this blog post as it is very simple and easy to understand and you can follow along in other languages easily.\n\n### Define the DFA\n\nFirst, we need to define the structure of our DFA. A DFA consists of a set of states, transitions between states based on input symbols, a start state, and one or more accept states.\n\n```go\npackage main\n\ntype DFA struct {\n\tnumStates    int\n\ttransitions  map[int]map[rune]int\n\tstartState   int\n\tacceptStates map[int]bool\n}\n```\n\nHere, `DFA` is a struct with the following fields:\n\n* `numStates`: The number of states in the DFA.\n* `transitions`: A map representing state transitions. Each state maps to another map where input symbols (runes) map to the next state.\n* `startState`: The start state of the DFA.\n* `acceptStates`: A set of accept states. We use a map for easy lookup.\n\nLet's also create a function to initialise a DFA.\n\n```go\nfunc NewDFA(numStates int, transitions map[int]map[rune]int, startState int, acceptStates map[int]bool) *DFA {\n\treturn &DFA{\n\t\tnumStates:    numStates,\n\t\ttransitions:  transitions,\n\t\tstartState:   startState,\n\t\tacceptStates: acceptStates,\n\t}\n}\n```\n\nThis function just creates a `DFA` with the provided parameters and returns a pointer to it.\n\n### Build the DFA for a Pattern\n\nNow, we need to build the DFA for a specific pattern. This involves setting up the states and transitions based on the pattern.\n\n* We need to determine the number of states required. The number of states required is equal to the length of the pattern plus one. This is because each character in the pattern corresponds to a state, and there is an additional state for the start state.\n* We also need to create a map to hold transitions for each state. This will be empty initially.\n* For each character in the pattern, we also need to set the transition from current state to the next state.\n* The last state (equal to the length of the pattern) will be an accept state.\n\n```go\nfunc buildDFA(pattern string) *DFA {\n\tnumStates := len(pattern) + 1\n\ttransitions := make(map[int]map[rune]int)\n\n\tfor i := 0; i < numStates; i++ {\n\t\ttransitions[i] = make(map[rune]int)\n\t}\n\n\tfor i, char := range pattern {\n\t\ttransitions[i][char] = i + 1\n\t}\n\n\tacceptStates := map[int]bool{numStates - 1: true}\n\treturn NewDFA(numStates, transitions, 0, acceptStates)\n}\n```\n\n* We calculate the number of states as `len(pattern) + 1`.\n* We initialise the `transitions` map to hold transitions for each state.\n* Then we iterate over the pattern and for each character, we set the transition from the current state to the next state.\n* Lastly we create an `acceptStates` map where the last state is marked as the accept state.\n\n### Simulate the DFA\n\nNow we'll make a function to simulate the DFA on an input string. This function will basically run our DFA and check if it accepts it.\n\n```go\nfunc (dfa *DFA) Simulate(input string) bool {\n\tcurrentState := dfa.startState\n\n\tfor _, symbol := range input {\n\t\tif nextState, exists := dfa.transitions[currentState][symbol]; exists {\n\t\t\tcurrentState = nextState\n\t\t} else {\n\t\t\tcurrentState = dfa.startState\n\t\t}\n\n\t\tif dfa.acceptStates[currentState] {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn dfa.acceptStates[currentState]\n}\n```\n\nThe algorithm begins at the DFA's initial state. For each symbol in the input string, it checks if a valid transition exists from the current state. If so, it moves to the next state. Otherwise, it resets to the start state. If the current state becomes an accept state at any point, it returns `true`. Finally, after processing all symbols, it returns whether the final state is an accept state.\n\n### Testing\n\nWe're pretty much done! Let's test our DFA with various input strings to see if it correctly matches the pattern.\n\n```go\nfunc main() {\n\tpattern := \"abc\"\n\tdfa := buildDFA(pattern)\n\n\tinputStrings := []string{\n\t\t\"xxabcxx\",   // Output: True (pattern \"abc\" is in the string)\n\t\t\"abc\",       // Output: True (pattern \"abc\" matches the entire string)\n\t\t\"ababc\",     // Output: True (pattern \"abc\" is in the string)\n\t\t\"defabcghi\", // Output: True (pattern \"abc\" is in the string)\n\t\t\"abdefgh\",   // Output: False (pattern \"abc\" is not in the string)\n\t\t\"aabbcc\",    // Output: False (pattern \"abc\" is not in the string)\n\t}\n\n\tfor _, input := range inputStrings {\n\t\tresult := dfa.Simulate(input)\n\t\tfmt.Printf(\"Input: %q -> Output: %v\\n\", input, result)\n\t}\n}\n```\n\nWe first build the DFA for the pattern `\"abc\"` and then simulate the DFA on various input strings.\n\nAnd this works flawlessly!\n\n```\nInput: \"xxabcxx\" -> Output: True\nInput: \"abc\" -> Output: True\nInput: \"ababc\" -> Output: True\nInput: \"defabcghi\" -> Output: True\nInput: \"abdefgh\" -> Output: False\nInput: \"aabbcc\" -> Output: False\n```\n\nThat was an intro to a very basic implementation of a DFA. DFAs are powerful tools that can be applied in various areas beyond pattern matching. They are used in the design of lexers, which are crucial in the process of compiling programming languages. DFAs also play a vital role in network protocols and text parsing algorithms.\n\nDFAs are also used in digital circuit design to model the behaviour of sequential logic circuits. They help in the development of microprocessors.\n\nNFAs, the other type of FSMs, are actually used to build regex engines, making them essential for complex pattern matching tasks in text processing and search algorithms.\n\nLet me know if you guys would be interested in learning about NFAs or exploring more advanced applications of DFAs and NFAs in computational theory and practical implementations.\n\nThank you for reading this and I hope you liked it!",
    "readTime": "15 min read",
    "author": "Priyanshu Chikara"
  }
]
